#Weizhou Wang, 1004421262, weizhou.wang@mail.utoronto.ca
#Jiabo Cui

===================================================Target1===================================================
This target has a buffer overflow vulnerability, because the strcpy() does not check if the character copied
from arg to buffer is out of the boundary of buffer. If we keep copying after exceeding the boundary, the 
character copied will overwrite the function's return address eventually. Here we use a large attack buffer to 
overwrite the return address of lab_main() to the beginning of the attack buffer, which stores the shellcode. 
Therefore, when the function returns, it will be redirected to execute the shellcode.

===================================================Target2===================================================
This target also has a buffer overflow vulnerability. The for loop in the foo() function copies arg into buf byte
by byte. Although there is a length constraint of 280, it is still longer than the 260 size of the buf, which gives
the attacker a chance to modify the len variable first. Afterwards, length is modified into 300 so that the attacker
is able to overwrite the return address of main to the begining of the buffer which is the shellcode. In this case, another
thing to be noticed is that since variable j is also between the return address and the buffer and we need to leave 
it unmodified so that the counter will function normally. Another thing is that since we encounter consecutive "0x00"
in our attack string, we need to use env variable to cat the attack string so that all the 0x00 will be read.

<shellcode><NOPs><len><NOPS><j><NOPs><return address>
===================================================Target3===================================================
This one also has a buffer overflow vulnerability, because the loop in bar() copies characters from arg to 
buffer (appends characters to "ECE5682022FT"). Although it sets the maximum number of characters copied to be
103, it is still larger than the size of buffer and big enough to overwrite the return address. Here we use
a large attack buffer to overflow the target buffer, and overwrite the return address of foo() to the address 
of shellcode. As a result, when foo() returns, the execution will be redirected to the shellcode.

===================================================Target4===================================================
Buffer overflow vulnerability: the loop in foo() copies characters from arg to buf with a limit len, which seems 
to avoid overwriting the return address, but we can modify its value because it is in stack and within the bound 
set by itself. Our attack buffer first overwrites len to be big enough to let us overwrite the return address, 
then we overwrite foo()'s return address to the shellcode. Note that '\x00' in attack buffer makes args terminate, 
so we use the env variables whenever there is a '\x00' to copy the whole attack buffer to the targetâ€™s stack.

===================================================Target5===================================================
Format string vulnerability: the snprintf() in foo() is unsafe because any format string specifier will sequencially 
read/overwrite unauthorized content in registers/stack. We use an attack buffer with the structure below. In the 
buffer, we add a number of %<i>x to collect enough written characters and increment the "pointer" to point to somewhere 
in formatString that stores the address of one of bytes of foo()'s return address. Then we used %hhn to overwrite the 
byte. We repeat the step until we overwrite the whole return address. Note that we reordered the ADDRs to minimize 
formatString's length.
<ADDR+3><P><ADDR+2><P><ADDR><P><ADDR+1><SHELLCODE><FORMAT_STRING>

===================================================Target6===================================================
This target contains a double free vulnerability, q is freed twice. In this case, we have implemented two fake tags(more precisely
2.5 tags) in the attack string. The left of the first tag is set to be pointing to the begining of p, and the right is point to 
the second fake tag. the left of the second fake tag does not matter so we set it to NOPS and the right is set to the return address.
When q is freed again, the block will be consolidate. Therefore, now the return string will be set to the begining of p. However, the
right of the start of p will be changed to the return address and will damage the shell code if we put the shell code at the beginning
of p. Therefore, we have put a jump instruction at the begining so that the return address will be first pointing to the jmp and then
jump to the shell code followed. 
